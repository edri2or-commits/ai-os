# Reconciler Design

**Version:** 1.0  
**Date:** 2025-12-01  
**Status:** Design Phase (Slice 2.4a)

---

## Table of Contents

1. [Overview](#overview)
2. [Change Request (CR) Architecture](#change-request-cr-architecture)
3. [CR Lifecycle](#cr-lifecycle)
4. [Observer ‚Üí CR Mapping](#observer--cr-mapping)
5. [HITL Approval Workflow](#hitl-approval-workflow)
6. [Safety Invariants](#safety-invariants)
7. [Implementation Roadmap](#implementation-roadmap)

---

## Overview

### Purpose

The **Reconciler** is the automated remediation component of the AI Life OS drift detection system. It:

1. **Receives** drift findings from the Observer
2. **Generates** Change Request (CR) proposals
3. **Coordinates** HITL approval for safety-critical changes
4. **Applies** approved changes to entities or system files
5. **Commits** changes to git with full audit trail

### Core Principles

- **Never bypass Truth Layer:** All changes go through git
- **Human-in-the-loop for risk:** MEDIUM/HIGH risk CRs require explicit approval
- **Atomic operations:** Changes are all-or-nothing (entity + CR status + git commit)
- **Audit trail:** Every modification has a corresponding CR file
- **Reversibility:** All changes can be undone via `git revert`

### Current Status

**Slice 2.4a (this document):**
- ‚úÖ CR schema defined
- ‚úÖ CR template created
- ‚úÖ Observer ‚Üí CR mapping documented
- ‚úÖ HITL workflow designed
- ‚úÖ Safety invariants established

**Future Slices:**
- ‚è≥ 2.4b: Minimal reconciler implementation (safe drift types only)
- ‚è≥ 2.4c: CR approval CLI
- ‚è≥ 2.4d: Expand drift coverage
- ‚è≥ 2.4e: Observer+Reconciler integration

---

## Change Request (CR) Architecture

### What is a CR?

A **Change Request (CR)** is a structured proposal for modifying an entity or system file to address a specific drift finding. 

CRs are:
- **Declarative:** Describe *what* should change, not *how*
- **Traceable:** Link to drift reports and git commits
- **Reviewable:** Human-readable YAML with clear rationale
- **Machine-validatable:** JSON Schema ensures consistency

### CR Structure

```yaml
# Metadata
cr_id: "CR-20251201-001"
timestamp: "2025-12-01T10:30:00Z"
generator: "observer"
status: "proposed"

# Drift Context
drift_type: "stale_timestamp"
drift_report_id: "DR-20251201-001"
affected_entity:
  type: "task"
  id: "task-20251128-001"
  path: "memory-bank/10_Projects/website-redesign/tasks/task-20251128-001.md"

# Proposed Change
proposed_changes:
  field: "updated_at"
  current_value: "2025-11-28T14:00:00Z"
  proposed_value: "2025-12-01T10:30:00Z"
  operation: "update"

# Justification
rationale: |
  Observer detected stale timestamp (3 days old, task still active).
  Updating to current timestamp to reflect ongoing work.

# Safety
risk_level: "low"
requires_approval: true
reversible: true
backup_path: null

# Audit Trail
created_by: "observer.py"
reviewed_by: null
applied_at: null
git_commit: null
rejection_reason: null
```

### CR Schema

**Location:** `docs/schemas/change_request.schema.json`

**Required Fields:**
- `cr_id` (format: `CR-YYYYMMDD-NNN`)
- `timestamp` (ISO 8601)
- `generator` (`observer` | `manual` | `reconciler`)
- `status` (`proposed` | `approved` | `rejected` | `applied`)
- `drift_type` (one of 5 Observer drift types)
- `affected_entity` (type, id, path)
- `proposed_changes` (field, operation, current/proposed values)
- `rationale` (human-readable explanation)
- `risk_level` (`low` | `medium` | `high`)
- `requires_approval` (boolean)
- `reversible` (boolean)

**Optional Fields:**
- `drift_report_id` (links to Observer report)
- `backup_path` (if file backup needed)
- Audit trail fields (set during workflow)

### CR Template

**Location:** `memory-bank/TEMPLATES/change_request_template.yaml`

The template includes:
- Full structure with inline comments
- 3 examples (git HEAD drift, orphaned task, broken link)
- Risk level guidance for each drift type

---

## CR Lifecycle

### States

```
proposed ‚Üí approved ‚Üí applied ‚Üí [committed to git]
       ‚Üò rejected
```

1. **Proposed:** CR generated by Observer/reconciler, awaiting review
2. **Approved:** Human (or auto-approval rule) has authorized the change
3. **Rejected:** Human has denied the change (with reason)
4. **Applied:** Change has been executed and committed to git

### Transitions

| From | To | Trigger | Action |
|------|-----|---------|--------|
| `proposed` | `approved` | User runs `reconciler approve CR-XXX` | Set `reviewed_by`, `status=approved` |
| `proposed` | `rejected` | User runs `reconciler reject CR-XXX --reason "..."` | Set `reviewed_by`, `rejection_reason`, `status=rejected` |
| `approved` | `applied` | Reconciler executes change | Update entity ‚Üí git commit ‚Üí set `applied_at`, `git_commit`, `status=applied` |

### Atomic Application

When applying a CR, the reconciler must perform these steps atomically:

1. **Backup** (if `backup_path` specified)
2. **Validate** CR schema
3. **Apply** change to entity file
4. **Git add** modified file
5. **Git commit** with CR reference
6. **Update CR** status to `applied` (add `applied_at`, `git_commit`)
7. **Write** updated CR file

If any step fails ‚Üí rollback everything and mark CR as failed.

---

## Observer ‚Üí CR Mapping

### Drift Type ‚Üí CR Action

| Drift Type | CR Action | Risk Level | Auto-Approvable? | Notes |
|------------|-----------|------------|------------------|-------|
| **git_head_drift** | Update `last_commit` in SYSTEM_STATE_COMPACT.json | LOW | YES (if <10 commits) | Metadata update, no entity modification |
| **stale_timestamp** | Update `updated_at` to current time | LOW | YES (if entity active) | Normalization, low risk |
| **orphaned_entity** | Add parent reference OR move to archive | MEDIUM | NO | Human must decide strategy |
| **broken_link** | Remove invalid link OR update to valid entity | MEDIUM | NO | May indicate deeper issue |
| **schema_violation** | Fix field (rename/add/remove) | MEDIUM-HIGH | NO | Validator should catch these early |

### Example CRs

#### Example 1: Git HEAD Drift (LOW risk)

```yaml
cr_id: "CR-20251201-002"
drift_type: "git_head_drift"
affected_entity:
  type: "system"
  id: "SYSTEM_STATE_COMPACT.json"
  path: "docs/system_state/SYSTEM_STATE_COMPACT.json"
proposed_changes:
  field: "last_commit"
  current_value: "43b308a"
  proposed_value: "eefc5d3"
  operation: "update"
rationale: |
  Truth Layer shows last_commit: 43b308a, but actual HEAD is eefc5d3.
  Updating metadata to match current git state (3 commits behind).
risk_level: "low"
requires_approval: false  # Auto-approvable
```

#### Example 2: Orphaned Task (MEDIUM risk)

```yaml
cr_id: "CR-20251201-003"
drift_type: "orphaned_entity"
affected_entity:
  type: "task"
  id: "task-20251130-005"
  path: "memory-bank/10_Projects/unknown-project/task-20251130-005.md"
proposed_changes:
  field: "parent_project_id"
  current_value: null
  proposed_value: "project-20251201-001"
  operation: "update"
rationale: |
  Task has no parent_project_id and lives in non-existent project directory.
  Proposed solution: link to active project "project-20251201-001".
  Alternative: move to 99_Archive/ if task is abandoned.
risk_level: "medium"
requires_approval: true  # Human must decide
```

#### Example 3: Broken Link (MEDIUM risk)

```yaml
cr_id: "CR-20251201-004"
drift_type: "broken_link"
affected_entity:
  type: "project"
  id: "project-20251201-001"
  path: "memory-bank/10_Projects/website-redesign/project.md"
proposed_changes:
  field: "parent_area_id"
  current_value: "area-20251101-999"
  proposed_value: null
  operation: "delete"
rationale: |
  Project references non-existent area "area-20251101-999".
  Proposed solution: remove the broken link.
  Alternative: create the missing area OR link to different area.
risk_level: "medium"
requires_approval: true  # Human must decide
```

---

## HITL Approval Workflow

### Workflow Steps

1. **Observer detects drift** ‚Üí generates CR file
   - CR written to `docs/system_state/change_requests/CR-YYYYMMDD-NNN.cr.yaml`
   - Status: `proposed`

2. **Reconciler lists pending CRs** (read-only)
   - Command: `reconciler list --status proposed`
   - Shows: cr_id, drift_type, risk_level, rationale summary

3. **User reviews CR** (manually open file OR via CLI preview)
   - Command: `reconciler show CR-20251201-001`
   - Displays: full CR content + affected entity preview

4. **User decides:**
   - **Approve:** `reconciler approve CR-20251201-001`
     - Updates CR: `status=approved`, `reviewed_by=<user>`
   - **Reject:** `reconciler reject CR-20251201-001 --reason "Not needed"`
     - Updates CR: `status=rejected`, `reviewed_by=<user>`, `rejection_reason=...`

5. **Reconciler applies approved CRs** (automatic OR manual trigger)
   - Command: `reconciler apply` (processes all `status=approved` CRs)
   - For each CR:
     - Validate schema
     - Apply change to entity
     - Git commit with CR reference
     - Update CR: `status=applied`, `applied_at=<now>`, `git_commit=<hash>`

6. **Rejected CRs** remain in directory for audit trail
   - Status: `rejected`
   - Contains `rejection_reason` field

### Auto-Approval (Optional, Future)

**Phase 2 (current):** All CRs require manual approval (conservative approach)

**Phase 3 (future):** LOW risk CRs with `requires_approval: false` can be auto-applied
- Still generate CR for audit trail
- Still git commit with CR reference
- User can review applied CRs: `reconciler list --status applied --since 1h`

---

## Git Safety Rules

**Purpose:** Ensure safe, atomic, and auditable git operations during CR application.

**These rules are concrete implementations of INV-CR-003 (git-reversible) and INV-CR-005 (atomic application).**

---

### Rule 1: NO `git add -A` in apply_cr

**Problem:** `git add -A` stages ALL changes in the working tree, including:
- Unrelated files modified by the user
- Files from other CRs being prepared
- Debug output, temporary files, uncommitted experiments

This breaks atomicity: a CR commit could include unrelated changes.

**Solution:** Targeted staging only.

**Implementation:**
- Each CR must compute a `touched_files` list (files modified by this CR)
- Reconciler stages ONLY those files: `git add <file1> <file2> ...`
- Alternatively: compute diff at apply time, verify staged files ‚äÜ touched_files

**Example:**
```python
# ‚ùå WRONG
def apply_cr_wrong(cr):
    modify_entity(cr)
    run_git_command(["git", "add", "-A"])  # Stages EVERYTHING
    run_git_command(["git", "commit", "-m", f"Apply {cr.cr_id}"])

# ‚úÖ CORRECT
def apply_cr_correct(cr):
    touched_files = compute_touched_files(cr)  # e.g., ["memory-bank/10_Projects/task.md"]
    modify_entity(cr)
    for file in touched_files:
        run_git_command(["git", "add", file])  # Stage only CR-related files
    run_git_command(["git", "commit", "-m", f"Apply {cr.cr_id}"])
```

---

### Rule 2: Working tree MUST be clean before apply

**Problem:** If there are uncommitted changes from:
- User's manual edits
- Other CRs in progress
- Previous failed apply operations

Then applying a CR could:
- Create merge conflicts
- Include unrelated changes in the commit
- Make rollback ambiguous

**Solution:** Pre-flight check.

**Implementation:**
```python
def check_working_tree_clean():
    result = subprocess.run(
        ["git", "status", "--porcelain"],
        capture_output=True, text=True
    )
    if result.stdout.strip():
        raise RuntimeError(
            "Cannot apply CR: working tree is not clean.\n"
            "Please commit, stash, or clean changes before retrying.\n"
            f"Uncommitted changes:\n{result.stdout}"
        )
```

**When to run:** Before EVERY `apply_cr` execution (even if applying multiple CRs in batch).

**User action on failure:**
- Commit their changes: `git commit -am "WIP: user changes"`
- Stash their changes: `git stash`
- Clean untracked files: `git clean -fd` (with caution)

---

### Rule 3: One commit per CR

**Problem:** Batching multiple CRs into one commit makes:
- Audit trail unclear (which CR caused which change?)
- Rollback difficult (need to revert multiple CRs together)
- Debugging harder (can't bisect individual CRs)

**Solution:** One CR = one commit.

**Implementation:**
```python
def apply_approved_crs(cr_ids):
    for cr_id in cr_ids:
        cr = load_cr(cr_id)
        
        # Apply this CR
        touched_files = apply_cr(cr)  # Returns list of modified files
        
        # Stage only this CR's files
        for file in touched_files:
            run_git_command(["git", "add", file])
        
        # Commit with CR reference
        commit_message = f"""Apply {cr.cr_id}: {cr.drift_type}

{cr.rationale}

Affected entity: {cr.affected_entity['path']}
Risk level: {cr.risk_level}
CR file: docs/system_state/change_requests/{cr.cr_id}.cr.yaml
"""
        run_git_command(["git", "commit", "-m", commit_message])
        
        # Update CR status
        cr.status = "applied"
        cr.applied_at = datetime.utcnow().isoformat()
        cr.git_commit = get_current_commit_hash()
        save_cr(cr)
```

**Commit message format:**
- First line: `Apply CR-YYYYMMDD-NNN: <drift_type>`
- Body: CR rationale + metadata
- Includes CR file path for easy lookup

---

### Rule 4: apply.log tracks all operations

**Purpose:** Audit trail for CR application (separate from git log).

**Location:** `docs/system_state/change_requests/apply.log`

**Format:** One line per CR applied (append-only, plain text)

**Fields:**
```
<timestamp> | <cr_id> | <status> | <commit_hash> | <files_touched>
```

**Example:**
```
2025-12-01T14:30:00Z | CR-20251201-001 | applied | a1b2c3d | memory-bank/10_Projects/task-001.md
2025-12-01T14:31:00Z | CR-20251201-002 | applied | e4f5g6h | docs/system_state/SYSTEM_STATE_COMPACT.json
2025-12-01T14:32:00Z | CR-20251201-003 | dry-run | - | memory-bank/20_Areas/area-health.md
```

**Usage:**
- `grep "applied" apply.log | wc -l` ‚Üí count applied CRs
- `grep "CR-20251201-001" apply.log` ‚Üí find specific CR
- `tail -n 20 apply.log` ‚Üí recent operations

**Implementation:**
```python
def log_apply(cr_id, status, commit_hash=None, touched_files=None):
    log_path = CHANGE_REQUESTS_DIR / "apply.log"
    timestamp = datetime.utcnow().isoformat()
    files_str = ",".join(touched_files) if touched_files else "-"
    commit_str = commit_hash if commit_hash else "-"
    
    with open(log_path, "a", encoding="utf-8") as f:
        f.write(f"{timestamp} | {cr_id} | {status} | {commit_str} | {files_str}\n")
```

---

### Rule 5: --limit flag with conservative default

**Problem:** Applying 50+ CRs in one run is risky:
- Hard to review all changes
- Difficult to rollback if something goes wrong
- May exceed context window if showing results

**Solution:** `--limit` flag with default = 10.

**Implementation:**
```python
# CLI
parser.add_argument(
    "--limit",
    type=int,
    default=10,
    help="Maximum number of CRs to apply in one run (default: 10)"
)

# Apply logic
def apply_approved_crs(limit=10):
    approved_crs = list_crs(status="approved")
    
    if len(approved_crs) > limit:
        print(f"‚ö†Ô∏è  Found {len(approved_crs)} approved CRs, limiting to {limit}")
        print(f"   Run again with --limit {len(approved_crs)} to apply all")
        approved_crs = approved_crs[:limit]
    
    for cr in approved_crs:
        apply_cr(cr)
```

**User override:**
```bash
# Apply only 5 CRs
python tools/reconciler.py apply --limit 5

# Apply all approved CRs (use with caution)
python tools/reconciler.py apply --limit 1000
```

**Recommendation:**
- Always run `--dry-run` FIRST to preview changes
- Start with small limits (5-10) until confident
- Increase limit gradually based on CR complexity

---

## Safety Invariants

### INV-CR-001: All entity modifications MUST go through CR system

**Rule:** Reconciler never edits entities directly.

**Rationale:** Every change has a CR file for audit trail.

**Enforcement:**
- Reconciler code checks: "Does CR exist for this change?"
- If manual edit needed ‚Üí create CR manually, then apply

**Violation Response:**
- Log warning: "Entity modified without CR"
- Observer flags as drift: "entity_modified_without_cr"

---

### INV-CR-002: HIGH risk CRs MUST require explicit approval

**Rule:** Never auto-approve schema violations, orphaned entities, broken links.

**Rationale:** These indicate deeper issues that need human judgment.

**Enforcement:**
- CR schema validation: `risk_level: "high"` ‚Üí `requires_approval: true`
- Auto-approval logic checks risk level before proceeding

**Violation Response:**
- Reject CR with error: "HIGH risk CRs cannot be auto-approved"

---

### INV-CR-003: Every CR MUST be git-reversible

**Rule:** All changes committed to git, `git revert <commit>` must restore previous state.

**Rationale:** Safety net for mistakes.

**Enforcement:**
- CR schema requires `reversible: true` (no false allowed)
- Reconciler validates: "Is entity tracked in git?"

**Violation Response:**
- Reject CR with error: "Entity not tracked in git, cannot guarantee reversibility"

---

### INV-CR-004: CRs are derived state [PROPOSAL]

**Rule:** CR files are NOT tracked in git (like drift reports).

**Rationale:** CRs are regenerable from Observer findings.

**Current Implementation:**
- `.gitignore` rules ignore `*.cr.yaml`
- CRs stored in `docs/system_state/change_requests/`

**IMPORTANT NOTE:**
This is a **design proposal** for Phase 2, not a permanent invariant. 

We may later decide that certain CRs (especially approved/applied ones) should be tracked in git for long-term audit. For example:
- Phase 2: All CRs are derived state (conservative default)
- Phase 3: Approved/applied CRs could be moved to `governance/change_requests_history/` and tracked in git
- Phase 4: Full CR history as part of Truth Layer

**This design choice can be revisited** based on operational experience.

---

### INV-CR-005: CR application is atomic

**Rule:** Either: update entity + commit + update CR status, OR: rollback everything on failure.

**Rationale:** No partial state (entity updated but CR status not updated).

**Enforcement:**
- Reconciler uses transaction-like logic:
  ```python
  try:
      backup_entity()
      apply_change_to_entity()
      git_add_and_commit()
      update_cr_status()
  except Exception:
      rollback_entity()
      mark_cr_as_failed()
      raise
  ```

**Violation Response:**
- Log error: "CR application failed, entity rolled back"
- CR status: `status=failed`, reason logged

---

## Implementation Roadmap

### Slice 2.4a ‚Äì Reconciler Design & CR Format (‚úÖ Current)

**Status:** Complete

**Deliverables:**
- ‚úÖ `docs/schemas/change_request.schema.json`
- ‚úÖ `memory-bank/TEMPLATES/change_request_template.yaml`
- ‚úÖ `docs/RECONCILER_DESIGN.md` (this file)
- ‚úÖ `.gitignore` rules for `change_requests/`

**No code implemented yet.**

---

### Slice 2.4b ‚Äì Minimal Reconciler Implementation ‚úÖ COMPLETE

**Date:** 2025-12-01  
**Goal:** Implement reconciler logic for 1-2 safe drift types only.

**Scope:**
- Python script: `tools/reconciler.py`
- Generate CR files from Observer findings
- HITL approval step (manual for now)
- Apply approved CRs (git HEAD drift + stale timestamps only)

**Safety:**
- LOW risk drift types only
- All changes require manual approval (conservative)
- No orphaned entity or broken link handling yet

**Duration:** ~1-2 hours

---

### Slice 2.4c ‚Äì Reconciler Apply Logic (üîÑ Current Slice)

**Goal:** Implement `apply_cr` logic to execute approved CRs safely.

**Scope:**
- `apply` command: processes approved CRs
- Git wrapper: targeted staging (NO `git add -A`)
- Working tree check: abort if not clean
- Apply log: track operations
- `--dry-run` + `--limit` flags

**Git Safety Rules (see section above):**
1. ‚úÖ NO `git add -A` ‚Äì stage only touched_files
2. ‚úÖ Working tree clean check ‚Äì abort if uncommitted changes
3. ‚úÖ One commit per CR ‚Äì clear audit trail
4. ‚úÖ apply.log ‚Äì separate from git log
5. ‚úÖ --limit flag ‚Äì default 10 CRs per run

**Apply Logic Implementation:**
- Compute `touched_files` for each CR
- Pre-flight checks: working tree clean, CR schema valid, entity exists
- Apply changes to entity file(s)
- Stage only touched files: `git add <file1> <file2>`
- Commit with CR reference in message
- Update CR status: `applied` + `git_commit` hash + `applied_at` timestamp
- Write to apply.log

**Safety:**
- Atomic: all-or-nothing (entity + commit + CR update + log)
- Rollback on failure: restore entity from backup
- `--dry-run`: show what would happen, no actual changes
- `--limit`: conservative default (10), prevent batch disasters

**Duration:** ~1-2 hours

---

### Slice 2.4d ‚Äì Expand Drift Coverage (‚è≥ Future)

**Goal:** Add orphaned entities and broken links resolution.

**Scope:**
- More sophisticated CR logic:
  - Orphaned entities: suggest parent OR archive
  - Broken links: suggest removal OR re-linking
- Still requires HITL approval (MEDIUM risk)

**Safety:**
- Human must decide strategy
- Reconciler proposes options, doesn't choose

**Duration:** ~1-2 hours

---

### Slice 2.4e ‚Äì Observer+Reconciler Integration (‚è≥ Future)

**Goal:** Observer can optionally generate CRs directly.

**Scope:**
- Observer flag: `--generate-crs` (optional)
- Scheduled reconciliation runs (n8n or Task Scheduler)
- Auto-apply LOW risk CRs (Phase 3 feature)

**Safety:**
- Default: manual approval for all CRs
- Phase 3: opt-in auto-approval for LOW risk

**Duration:** ~1 hour

---

## Research Alignment

**Research Families:**
- **#5: Safety/Governance/Drift** (08.md: Dual Truth Architecture, Observed State pattern)
- **#2: Deterministic Reliability** (02.md: HITL approval, git-backed safety)
- **#1: Architecture/Kernel** (12.md: Truth Layer as source of truth)

**Key Principles:**
- Chat ‚Üí Spec ‚Üí Change (this design doc is the Spec)
- Human-in-the-loop for safety-critical decisions
- Git as infinite undo (all changes reversible)
- Proactive drift detection + remediation loop

---

## Apply Logic Implementation

**Purpose:** Detailed design for `apply_cr` function (Slice 2.4c).

---

### High-Level Flow

```
1. User runs: reconciler.py apply [--dry-run] [--limit N]
2. Load approved CRs (status=approved)
3. Apply limit (default: 10)
4. For each CR:
   a. Pre-flight checks
   b. Compute touched_files
   c. Apply changes to entity
   d. Git stage + commit
   e. Update CR status
   f. Log to apply.log
5. Report summary
```

---

### Step-by-Step: apply_cr(cr)

**Input:** ChangeRequest object (status=approved)

**Output:** 
- Success: commit hash, list of touched files
- Failure: exception with rollback

**Steps:**

#### Step 1: Pre-flight Checks

```python
def apply_cr(cr: ChangeRequest, dry_run=False) -> Dict[str, Any]:
    # 1.1: Check working tree is clean
    check_working_tree_clean()  # Raises RuntimeError if not clean
    
    # 1.2: Validate CR schema
    if not cr.validate_schema():
        raise ValueError(f"CR {cr.cr_id} failed schema validation")
    
    # 1.3: Check CR status
    if cr.status != "approved":
        raise ValueError(f"CR {cr.cr_id} is not approved (status: {cr.status})")
    
    # 1.4: Check entity file exists
    entity_path = REPO_ROOT / cr.affected_entity["path"]
    if not entity_path.exists():
        raise FileNotFoundError(f"Entity not found: {entity_path}")
```

#### Step 2: Compute touched_files

```python
    # 2.1: Determine which files will be modified
    touched_files = compute_touched_files(cr)
    # For most CRs: just the entity file
    # For git_head_drift: SYSTEM_STATE_COMPACT.json
    # For future: might touch multiple files
    
    if not touched_files:
        raise ValueError(f"CR {cr.cr_id} has no touched_files (invalid CR)")
```

#### Step 3: Backup (if needed)

```python
    # 3.1: Create backup if specified in CR
    if cr.backup_path:
        backup_entity(entity_path, cr.backup_path)
```

#### Step 4: Apply Changes

```python
    # 4.1: Read entity file
    with open(entity_path, "r", encoding="utf-8") as f:
        content = f.read()
    
    # 4.2: Parse YAML frontmatter + body
    entity_data = parse_entity(content)
    
    # 4.3: Apply CR changes
    if cr.proposed_changes["operation"] == "update":
        field = cr.proposed_changes["field"]
        new_value = cr.proposed_changes["proposed_value"]
        entity_data[field] = new_value
    elif cr.proposed_changes["operation"] == "delete":
        field = cr.proposed_changes["field"]
        del entity_data[field]
    # ... other operations
    
    # 4.4: Write updated entity
    if not dry_run:
        with open(entity_path, "w", encoding="utf-8") as f:
            f.write(serialize_entity(entity_data))
```

#### Step 5: Git Operations

```python
    if not dry_run:
        # 5.1: Stage ONLY touched files (NO git add -A)
        for file in touched_files:
            run_git_command(["git", "add", str(file)])
        
        # 5.2: Commit with CR reference
        commit_message = format_commit_message(cr)
        run_git_command(["git", "commit", "-m", commit_message])
        
        # 5.3: Get commit hash
        commit_hash = get_current_commit_hash()
```

#### Step 6: Update CR Status

```python
    if not dry_run:
        # 6.1: Update CR metadata
        cr.status = "applied"
        cr.applied_at = datetime.utcnow().isoformat()
        cr.git_commit = commit_hash
        
        # 6.2: Save CR file
        cr_path = CHANGE_REQUESTS_DIR / f"{cr.cr_id}.cr.yaml"
        cr.save(cr_path)
```

#### Step 7: Log Operation

```python
    # 7.1: Write to apply.log
    log_apply(
        cr_id=cr.cr_id,
        status="applied" if not dry_run else "dry-run",
        commit_hash=commit_hash if not dry_run else None,
        touched_files=touched_files
    )
```

#### Step 8: Return Summary

```python
    return {
        "cr_id": cr.cr_id,
        "status": "applied" if not dry_run else "dry-run",
        "commit_hash": commit_hash if not dry_run else None,
        "touched_files": touched_files
    }
```

---

### Error Handling & Rollback

```python
def apply_cr_with_rollback(cr: ChangeRequest, dry_run=False):
    backup_content = None
    entity_path = REPO_ROOT / cr.affected_entity["path"]
    
    try:
        # Backup entity
        if entity_path.exists():
            with open(entity_path, "r", encoding="utf-8") as f:
                backup_content = f.read()
        
        # Apply CR
        result = apply_cr(cr, dry_run=dry_run)
        return result
        
    except Exception as e:
        # Rollback entity
        if backup_content and not dry_run:
            with open(entity_path, "w", encoding="utf-8") as f:
                f.write(backup_content)
        
        # Mark CR as failed
        cr.status = "failed"
        cr.rejection_reason = f"Apply failed: {str(e)}"
        cr.save(CHANGE_REQUESTS_DIR / f"{cr.cr_id}.cr.yaml")
        
        # Log failure
        log_apply(cr.cr_id, "failed", None, None)
        
        raise
```

---

### Helper Functions

#### compute_touched_files(cr)

```python
def compute_touched_files(cr: ChangeRequest) -> List[Path]:
    """
    Determine which files will be modified by this CR.
    
    Most CRs touch 1 file (the affected entity).
    Some CRs might touch multiple files (e.g., moving entity + updating parent).
    """
    files = []
    
    # Primary entity file
    entity_path = Path(cr.affected_entity["path"])
    files.append(entity_path)
    
    # CR file itself (status will change)
    cr_path = Path(f"docs/system_state/change_requests/{cr.cr_id}.cr.yaml")
    files.append(cr_path)
    
    # Future: add logic for CRs that touch multiple entities
    
    return files
```

#### check_working_tree_clean()

```python
def check_working_tree_clean():
    """
    Verify no uncommitted changes exist.
    Raises RuntimeError if working tree is not clean.
    """
    result = subprocess.run(
        ["git", "status", "--porcelain"],
        cwd=REPO_ROOT,
        capture_output=True,
        text=True,
        check=True
    )
    
    if result.stdout.strip():
        raise RuntimeError(
            "Cannot apply CR: working tree is not clean.\n"
            "Please commit, stash, or clean changes before retrying.\n\n"
            "Uncommitted changes:\n" + result.stdout
        )
```

#### format_commit_message(cr)

```python
def format_commit_message(cr: ChangeRequest) -> str:
    """
    Generate git commit message for a CR.
    """
    return f"""Apply {cr.cr_id}: {cr.drift_type}

{cr.rationale}

Affected entity: {cr.affected_entity['path']}
Risk level: {cr.risk_level}
CR file: docs/system_state/change_requests/{cr.cr_id}.cr.yaml
"""
```

---

### CLI: apply command

```python
def cmd_apply(args):
    """Apply approved CRs"""
    reconciler = Reconciler()
    
    # Load approved CRs
    approved_crs = reconciler.list_crs(status="approved")
    
    if not approved_crs:
        print("‚ÑπÔ∏è  No approved CRs to apply")
        return
    
    # Apply limit
    if len(approved_crs) > args.limit:
        print(f"‚ö†Ô∏è  Found {len(approved_crs)} approved CRs, limiting to {args.limit}")
        print(f"   Run again with --limit {len(approved_crs)} to apply all")
        approved_crs = approved_crs[:args.limit]
    
    # Dry-run or real apply
    mode = "DRY-RUN" if args.dry_run else "APPLY"
    print(f"\n{mode}: Processing {len(approved_crs)} CR(s)...\n")
    
    results = []
    for cr in approved_crs:
        try:
            result = reconciler.apply_cr_with_rollback(cr, dry_run=args.dry_run)
            results.append(result)
            
            status_icon = "üîç" if args.dry_run else "‚úÖ"
            print(f"{status_icon} {cr.cr_id} ({cr.drift_type})")
            if not args.dry_run:
                print(f"   Commit: {result['commit_hash'][:7]}")
            print(f"   Files: {', '.join(str(f) for f in result['touched_files'])}")
            
        except Exception as e:
            print(f"‚ùå {cr.cr_id} FAILED: {e}")
    
    # Summary
    print(f"\n{'='*70}")
    if args.dry_run:
        print(f"DRY-RUN complete: {len(results)}/{len(approved_crs)} CRs would succeed")
        print("Run without --dry-run to apply changes")
    else:
        print(f"APPLY complete: {len(results)}/{len(approved_crs)} CRs applied successfully")
```

---

## Apply Log Format

**Location:** `docs/system_state/change_requests/apply.log`

**Purpose:** 
- Audit trail separate from git log
- Quick lookup of applied CRs
- Track dry-run vs real apply operations

**Format:** Plain text, pipe-delimited, append-only

**Schema:**
```
<ISO_TIMESTAMP> | <CR_ID> | <STATUS> | <COMMIT_HASH> | <FILES_TOUCHED>
```

**Fields:**
- `ISO_TIMESTAMP`: When operation occurred (UTC, ISO 8601)
- `CR_ID`: Change Request ID (e.g., CR-20251201-001)
- `STATUS`: Operation result (applied | dry-run | failed)
- `COMMIT_HASH`: Git commit hash (7-40 chars, or "-" if dry-run/failed)
- `FILES_TOUCHED`: Comma-separated list of modified files (or "-" if failed)

**Example Log:**
```
2025-12-01T14:30:00Z | CR-20251201-001 | applied | a1b2c3d | memory-bank/10_Projects/task-001.md,docs/system_state/change_requests/CR-20251201-001.cr.yaml
2025-12-01T14:31:15Z | CR-20251201-002 | applied | e4f5g6h | docs/system_state/SYSTEM_STATE_COMPACT.json,docs/system_state/change_requests/CR-20251201-002.cr.yaml
2025-12-01T14:32:00Z | CR-20251201-003 | dry-run | - | memory-bank/20_Areas/area-health.md,docs/system_state/change_requests/CR-20251201-003.cr.yaml
2025-12-01T14:35:00Z | CR-20251201-004 | failed | - | -
```

**Usage Examples:**

```bash
# Count applied CRs
grep "applied" apply.log | wc -l

# Find specific CR
grep "CR-20251201-001" apply.log

# Recent operations (last 20)
tail -n 20 apply.log

# CRs applied in last hour
grep "$(date -u +%Y-%m-%dT%H)" apply.log

# Failed operations
grep "failed" apply.log
```

**Maintenance:**
- File grows monotonically (1 line per operation)
- No rotation needed (plain text, ~100 bytes per line)
- Tracked in git (NOT in .gitignore, unlike CR files)
- Can be analyzed with standard Unix tools (grep, awk, wc)

**Why separate from git log?**
- Git log shows commits (after-the-fact)
- Apply log shows operations (including dry-runs and failures)
- Apply log is easier to parse programmatically
- Apply log includes CR metadata (drift_type, risk_level)

---

**Document Version:** 1.1  
**Last Updated:** 2025-12-01  
**Next Review:** After Slice 2.4c (apply logic implementation)
