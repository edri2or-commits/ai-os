# Reconciler Design

**Version:** 1.0  
**Date:** 2025-12-01  
**Status:** Design Phase (Slice 2.4a)

---

## Table of Contents

1. [Overview](#overview)
2. [Change Request (CR) Architecture](#change-request-cr-architecture)
3. [CR Lifecycle](#cr-lifecycle)
4. [Observer → CR Mapping](#observer--cr-mapping)
5. [HITL Approval Workflow](#hitl-approval-workflow)
6. [Safety Invariants](#safety-invariants)
7. [Implementation Roadmap](#implementation-roadmap)

---

## Overview

### Purpose

The **Reconciler** is the automated remediation component of the AI Life OS drift detection system. It:

1. **Receives** drift findings from the Observer
2. **Generates** Change Request (CR) proposals
3. **Coordinates** HITL approval for safety-critical changes
4. **Applies** approved changes to entities or system files
5. **Commits** changes to git with full audit trail

### Core Principles

- **Never bypass Truth Layer:** All changes go through git
- **Human-in-the-loop for risk:** MEDIUM/HIGH risk CRs require explicit approval
- **Atomic operations:** Changes are all-or-nothing (entity + CR status + git commit)
- **Audit trail:** Every modification has a corresponding CR file
- **Reversibility:** All changes can be undone via `git revert`

### Current Status

**Slice 2.4a (this document):**
- ✅ CR schema defined
- ✅ CR template created
- ✅ Observer → CR mapping documented
- ✅ HITL workflow designed
- ✅ Safety invariants established

**Future Slices:**
- ⏳ 2.4b: Minimal reconciler implementation (safe drift types only)
- ⏳ 2.4c: CR approval CLI
- ⏳ 2.4d: Expand drift coverage
- ⏳ 2.4e: Observer+Reconciler integration

---

## Change Request (CR) Architecture

### What is a CR?

A **Change Request (CR)** is a structured proposal for modifying an entity or system file to address a specific drift finding. 

CRs are:
- **Declarative:** Describe *what* should change, not *how*
- **Traceable:** Link to drift reports and git commits
- **Reviewable:** Human-readable YAML with clear rationale
- **Machine-validatable:** JSON Schema ensures consistency

### CR Structure

```yaml
# Metadata
cr_id: "CR-20251201-001"
timestamp: "2025-12-01T10:30:00Z"
generator: "observer"
status: "proposed"

# Drift Context
drift_type: "stale_timestamp"
drift_report_id: "DR-20251201-001"
affected_entity:
  type: "task"
  id: "task-20251128-001"
  path: "memory-bank/10_Projects/website-redesign/tasks/task-20251128-001.md"

# Proposed Change
proposed_changes:
  field: "updated_at"
  current_value: "2025-11-28T14:00:00Z"
  proposed_value: "2025-12-01T10:30:00Z"
  operation: "update"

# Justification
rationale: |
  Observer detected stale timestamp (3 days old, task still active).
  Updating to current timestamp to reflect ongoing work.

# Safety
risk_level: "low"
requires_approval: true
reversible: true
backup_path: null

# Audit Trail
created_by: "observer.py"
reviewed_by: null
applied_at: null
git_commit: null
rejection_reason: null
```

### CR Schema

**Location:** `docs/schemas/change_request.schema.json`

**Required Fields:**
- `cr_id` (format: `CR-YYYYMMDD-NNN`)
- `timestamp` (ISO 8601)
- `generator` (`observer` | `manual` | `reconciler`)
- `status` (`proposed` | `approved` | `rejected` | `applied`)
- `drift_type` (one of 5 Observer drift types)
- `affected_entity` (type, id, path)
- `proposed_changes` (field, operation, current/proposed values)
- `rationale` (human-readable explanation)
- `risk_level` (`low` | `medium` | `high`)
- `requires_approval` (boolean)
- `reversible` (boolean)

**Optional Fields:**
- `drift_report_id` (links to Observer report)
- `backup_path` (if file backup needed)
- Audit trail fields (set during workflow)

### CR Template

**Location:** `memory-bank/TEMPLATES/change_request_template.yaml`

The template includes:
- Full structure with inline comments
- 3 examples (git HEAD drift, orphaned task, broken link)
- Risk level guidance for each drift type

---

## CR Lifecycle

### States

```
proposed → approved → applied → [committed to git]
       ↘ rejected
```

1. **Proposed:** CR generated by Observer/reconciler, awaiting review
2. **Approved:** Human (or auto-approval rule) has authorized the change
3. **Rejected:** Human has denied the change (with reason)
4. **Applied:** Change has been executed and committed to git

### Transitions

| From | To | Trigger | Action |
|------|-----|---------|--------|
| `proposed` | `approved` | User runs `reconciler approve CR-XXX` | Set `reviewed_by`, `status=approved` |
| `proposed` | `rejected` | User runs `reconciler reject CR-XXX --reason "..."` | Set `reviewed_by`, `rejection_reason`, `status=rejected` |
| `approved` | `applied` | Reconciler executes change | Update entity → git commit → set `applied_at`, `git_commit`, `status=applied` |

### Atomic Application

When applying a CR, the reconciler must perform these steps atomically:

1. **Backup** (if `backup_path` specified)
2. **Validate** CR schema
3. **Apply** change to entity file
4. **Git add** modified file
5. **Git commit** with CR reference
6. **Update CR** status to `applied` (add `applied_at`, `git_commit`)
7. **Write** updated CR file

If any step fails → rollback everything and mark CR as failed.

---

## Observer → CR Mapping

### Drift Type → CR Action

| Drift Type | CR Action | Risk Level | Auto-Approvable? | Notes |
|------------|-----------|------------|------------------|-------|
| **git_head_drift** | Update `last_commit` in SYSTEM_STATE_COMPACT.json | LOW | YES (if <10 commits) | Metadata update, no entity modification |
| **stale_timestamp** | Update `updated_at` to current time | LOW | YES (if entity active) | Normalization, low risk |
| **orphaned_entity** | Add parent reference OR move to archive | MEDIUM | NO | Human must decide strategy |
| **broken_link** | Remove invalid link OR update to valid entity | MEDIUM | NO | May indicate deeper issue |
| **schema_violation** | Fix field (rename/add/remove) | MEDIUM-HIGH | NO | Validator should catch these early |

### Example CRs

#### Example 1: Git HEAD Drift (LOW risk)

```yaml
cr_id: "CR-20251201-002"
drift_type: "git_head_drift"
affected_entity:
  type: "system"
  id: "SYSTEM_STATE_COMPACT.json"
  path: "docs/system_state/SYSTEM_STATE_COMPACT.json"
proposed_changes:
  field: "last_commit"
  current_value: "43b308a"
  proposed_value: "eefc5d3"
  operation: "update"
rationale: |
  Truth Layer shows last_commit: 43b308a, but actual HEAD is eefc5d3.
  Updating metadata to match current git state (3 commits behind).
risk_level: "low"
requires_approval: false  # Auto-approvable
```

#### Example 2: Orphaned Task (MEDIUM risk)

```yaml
cr_id: "CR-20251201-003"
drift_type: "orphaned_entity"
affected_entity:
  type: "task"
  id: "task-20251130-005"
  path: "memory-bank/10_Projects/unknown-project/task-20251130-005.md"
proposed_changes:
  field: "parent_project_id"
  current_value: null
  proposed_value: "project-20251201-001"
  operation: "update"
rationale: |
  Task has no parent_project_id and lives in non-existent project directory.
  Proposed solution: link to active project "project-20251201-001".
  Alternative: move to 99_Archive/ if task is abandoned.
risk_level: "medium"
requires_approval: true  # Human must decide
```

#### Example 3: Broken Link (MEDIUM risk)

```yaml
cr_id: "CR-20251201-004"
drift_type: "broken_link"
affected_entity:
  type: "project"
  id: "project-20251201-001"
  path: "memory-bank/10_Projects/website-redesign/project.md"
proposed_changes:
  field: "parent_area_id"
  current_value: "area-20251101-999"
  proposed_value: null
  operation: "delete"
rationale: |
  Project references non-existent area "area-20251101-999".
  Proposed solution: remove the broken link.
  Alternative: create the missing area OR link to different area.
risk_level: "medium"
requires_approval: true  # Human must decide
```

---

## HITL Approval Workflow

### Workflow Steps

1. **Observer detects drift** → generates CR file
   - CR written to `docs/system_state/change_requests/CR-YYYYMMDD-NNN.cr.yaml`
   - Status: `proposed`

2. **Reconciler lists pending CRs** (read-only)
   - Command: `reconciler list --status proposed`
   - Shows: cr_id, drift_type, risk_level, rationale summary

3. **User reviews CR** (manually open file OR via CLI preview)
   - Command: `reconciler show CR-20251201-001`
   - Displays: full CR content + affected entity preview

4. **User decides:**
   - **Approve:** `reconciler approve CR-20251201-001`
     - Updates CR: `status=approved`, `reviewed_by=<user>`
   - **Reject:** `reconciler reject CR-20251201-001 --reason "Not needed"`
     - Updates CR: `status=rejected`, `reviewed_by=<user>`, `rejection_reason=...`

5. **Reconciler applies approved CRs** (automatic OR manual trigger)
   - Command: `reconciler apply` (processes all `status=approved` CRs)
   - For each CR:
     - Validate schema
     - Apply change to entity
     - Git commit with CR reference
     - Update CR: `status=applied`, `applied_at=<now>`, `git_commit=<hash>`

6. **Rejected CRs** remain in directory for audit trail
   - Status: `rejected`
   - Contains `rejection_reason` field

### Auto-Approval (Optional, Future)

**Phase 2 (current):** All CRs require manual approval (conservative approach)

**Phase 3 (future):** LOW risk CRs with `requires_approval: false` can be auto-applied
- Still generate CR for audit trail
- Still git commit with CR reference
- User can review applied CRs: `reconciler list --status applied --since 1h`

---

## Safety Invariants

### INV-CR-001: All entity modifications MUST go through CR system

**Rule:** Reconciler never edits entities directly.

**Rationale:** Every change has a CR file for audit trail.

**Enforcement:**
- Reconciler code checks: "Does CR exist for this change?"
- If manual edit needed → create CR manually, then apply

**Violation Response:**
- Log warning: "Entity modified without CR"
- Observer flags as drift: "entity_modified_without_cr"

---

### INV-CR-002: HIGH risk CRs MUST require explicit approval

**Rule:** Never auto-approve schema violations, orphaned entities, broken links.

**Rationale:** These indicate deeper issues that need human judgment.

**Enforcement:**
- CR schema validation: `risk_level: "high"` → `requires_approval: true`
- Auto-approval logic checks risk level before proceeding

**Violation Response:**
- Reject CR with error: "HIGH risk CRs cannot be auto-approved"

---

### INV-CR-003: Every CR MUST be git-reversible

**Rule:** All changes committed to git, `git revert <commit>` must restore previous state.

**Rationale:** Safety net for mistakes.

**Enforcement:**
- CR schema requires `reversible: true` (no false allowed)
- Reconciler validates: "Is entity tracked in git?"

**Violation Response:**
- Reject CR with error: "Entity not tracked in git, cannot guarantee reversibility"

---

### INV-CR-004: CRs are derived state [PROPOSAL]

**Rule:** CR files are NOT tracked in git (like drift reports).

**Rationale:** CRs are regenerable from Observer findings.

**Current Implementation:**
- `.gitignore` rules ignore `*.cr.yaml`
- CRs stored in `docs/system_state/change_requests/`

**IMPORTANT NOTE:**
This is a **design proposal** for Phase 2, not a permanent invariant. 

We may later decide that certain CRs (especially approved/applied ones) should be tracked in git for long-term audit. For example:
- Phase 2: All CRs are derived state (conservative default)
- Phase 3: Approved/applied CRs could be moved to `governance/change_requests_history/` and tracked in git
- Phase 4: Full CR history as part of Truth Layer

**This design choice can be revisited** based on operational experience.

---

### INV-CR-005: CR application is atomic

**Rule:** Either: update entity + commit + update CR status, OR: rollback everything on failure.

**Rationale:** No partial state (entity updated but CR status not updated).

**Enforcement:**
- Reconciler uses transaction-like logic:
  ```python
  try:
      backup_entity()
      apply_change_to_entity()
      git_add_and_commit()
      update_cr_status()
  except Exception:
      rollback_entity()
      mark_cr_as_failed()
      raise
  ```

**Violation Response:**
- Log error: "CR application failed, entity rolled back"
- CR status: `status=failed`, reason logged

---

## Implementation Roadmap

### Slice 2.4a – Reconciler Design & CR Format (✅ Current)

**Status:** Complete

**Deliverables:**
- ✅ `docs/schemas/change_request.schema.json`
- ✅ `memory-bank/TEMPLATES/change_request_template.yaml`
- ✅ `docs/RECONCILER_DESIGN.md` (this file)
- ✅ `.gitignore` rules for `change_requests/`

**No code implemented yet.**

---

### Slice 2.4b – Minimal Reconciler Implementation

**Goal:** Implement reconciler logic for 1-2 safe drift types only.

**Scope:**
- Python script: `tools/reconciler.py`
- Generate CR files from Observer findings
- HITL approval step (manual for now)
- Apply approved CRs (git HEAD drift + stale timestamps only)

**Safety:**
- LOW risk drift types only
- All changes require manual approval (conservative)
- No orphaned entity or broken link handling yet

**Duration:** ~1-2 hours

---

### Slice 2.4c – CR Approval CLI

**Goal:** Simple CLI for approving/rejecting CRs.

**Scope:**
- Commands: `reconciler list`, `reconciler show`, `reconciler approve`, `reconciler reject`
- Interactive mode: show CR → ask user → update status
- Apply approved CRs: `reconciler apply`

**Safety:**
- Read CR file → validate schema → show to user → wait for input
- Clear error messages if CR invalid

**Duration:** ~1 hour

---

### Slice 2.4d – Expand Drift Coverage

**Goal:** Add orphaned entities and broken links resolution.

**Scope:**
- More sophisticated CR logic:
  - Orphaned entities: suggest parent OR archive
  - Broken links: suggest removal OR re-linking
- Still requires HITL approval (MEDIUM risk)

**Safety:**
- Human must decide strategy
- Reconciler proposes options, doesn't choose

**Duration:** ~1-2 hours

---

### Slice 2.4e – Observer+Reconciler Integration

**Goal:** Observer can optionally generate CRs directly.

**Scope:**
- Observer flag: `--generate-crs` (optional)
- Scheduled reconciliation runs (n8n or Task Scheduler)
- Auto-apply LOW risk CRs (Phase 3 feature)

**Safety:**
- Default: manual approval for all CRs
- Phase 3: opt-in auto-approval for LOW risk

**Duration:** ~1 hour

---

## Research Alignment

**Research Families:**
- **#5: Safety/Governance/Drift** (08.md: Dual Truth Architecture, Observed State pattern)
- **#2: Deterministic Reliability** (02.md: HITL approval, git-backed safety)
- **#1: Architecture/Kernel** (12.md: Truth Layer as source of truth)

**Key Principles:**
- Chat → Spec → Change (this design doc is the Spec)
- Human-in-the-loop for safety-critical decisions
- Git as infinite undo (all changes reversible)
- Proactive drift detection + remediation loop

---

**Document Version:** 1.0  
**Last Updated:** 2025-12-01  
**Next Review:** After Slice 2.4b (reconciler implementation)
